package iomeshage

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	log "github.com/sandia-minimega/minimega/v2/pkg/minilog"

	"github.com/fsnotify/fsnotify"
	"github.com/twmb/murmur3"
)

// ignoredDirectories is a list of strings to look for in directory paths to be
// ignored when adding directories to the file system event watcher.
//
// miniccc_responses - don't hash files generated by miniccc, since they rarely
// need to be transferred between nodes.
// transfer_ - don't hash file parts as they're being transferred. Instead, just
// wait for the CREATE event for the final, combined file.
var ignoredDirectories = []string{"miniccc_responses", "transfer_"}

// startHasher generates a Murmur3 hash for all existing files and also watches
// for new or updated files and generates a hash for them as well.
func (iom *IOMeshage) startHasher() {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal("creating file watcher: %v", err)
	}

	defer watcher.Close()

	// This goroutine continually processes events generated by the fsnotify
	// watcher and hashes files in the background as needed to help speed things
	// up when the hash actually needs to be used.
	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}

				if ignoreDirectory(event.Name) {
					continue
				}

				log.Info("NEW FSNOTIFY EVENT: %s", event)

				if event.Has(fsnotify.Create) {
					stat, err := os.Stat(event.Name)
					if err != nil {
						log.Error("getting stats for newly created file %s: %v", event.Name, err)
						continue
					}

					if stat.IsDir() {
						log.Info("adding new directory %s to watcher", event.Name)
						watcher.Add(event.Name)
					} else {
						log.Info("adding new file %s to list", event.Name)

						if stat.Size() > 0 {
							log.Info("getting hash for file %s", event.Name)

							go func() {
								hash, err := hashFile(event.Name)
								if err != nil {
									log.Error("getting hash for file %s: %v", event.Name, err)
									return
								}

								iom.updateHash(event.Name, hash)
							}()
						}
					}
				}

				if event.Has(fsnotify.Write) {
					log.Info("getting hash for file %s", event.Name)

					go func() {
						hash, err := hashFile(event.Name)
						if err != nil {
							log.Error("getting hash for file %s: %v", event.Name, err)
							return
						}

						iom.updateHash(event.Name, hash)
					}()
				}

				// TODO: when a file is transferred over the mesh, it's transferred in
				// parts. A temporary directory whose name begins with "transfer_" is
				// created, and all the parts are written to this temporary directory.
				// Once all the parts have been transferred, they're combined into a
				// single file, which results in a WRITE event for the new combined
				// file. To avoid hashing all the individual parts, we don't watch
				// directories that start with "transfer_" and just wait for the WRITE
				// event for the resulting combined file.

				// TODO: figure out which events should trigger an update to an existing
				// FileInfo's ModTime field. Just WRITE events? Or WRITE and CHMOD events?

				// TODO (future): figure out best way to handle detection of files being
				// moved.  May not happen that often, so not something to worry about
				// right now.
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}

				log.Error("watching for file events: %v", err)
			}
		}
	}()

	files, err := iom.List("/", true)
	if err != nil {
		log.Fatal("listing files: %v", err)
	}

	// This loop is only run once at startup, and creates a new goroutine for
	// each existing file that needs to be hashed.
	for _, info := range files {
		if ignoreDirectory(info.Path) {
			continue
		}

		if info.Size == 0 {
			continue
		}

		go func(info FileInfo) {
			hash, err := hashFile(info.Path)
			if err != nil {
				log.Error("getting hash for file %s: %v", info.Path, err)
				return
			}

			iom.updateHash(info.Path, hash)
		}(info)
	}

	// Don't start watching for fsnotify events until after we've already started
	// hashing all the existing files. There's a very small, very unlikely chance
	// that a new file could be created between the time when we walked all the
	// existing files and we start watching for new files.
	watcher.Add(iom.base)

	err = filepath.Walk(iom.base, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if ignoreDirectory(path) {
			return nil
		}

		if info.IsDir() {
			watcher.Add(path)
		}

		return nil
	})

	if err != nil {
		log.Fatal("walking %s", iom.base)
	}

	// Prevent this function from ever returning so the fsnotify event processing
	// goroutine will stay in scope.
	<-make(chan struct{})
}

// hashFile generates a Murmur3 hash for the file at the given path.
func hashFile(path string) (string, error) {
	file, err := os.Open(path)
	if err != nil {
		return "", fmt.Errorf("opening file %s for hashing: %w", path, err)
	}

	defer file.Close()
	start := time.Now()

	hasher := murmur3.New64()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", fmt.Errorf("hashing file: %w", err)
	}

	hash := fmt.Sprintf("%x", hasher.Sum(nil))

	log.Info("hashing %s (%s) took %s", path, hash, time.Since(start))

	return hash, nil
}

// ignoreDirectory checks to see if the given path contains any of the
// ignoredDirectories.
func ignoreDirectory(path string) bool {
	for _, ignore := range ignoredDirectories {
		if strings.Contains(path, ignore) {
			return true
		}
	}

	return false
}
