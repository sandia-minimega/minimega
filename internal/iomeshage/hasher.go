package iomeshage

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	log "github.com/sandia-minimega/minimega/v2/pkg/minilog"

	"github.com/fsnotify/fsnotify"
	"github.com/twmb/murmur3"
)

func (iom *IOMeshage) startHasher() {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal("creating file watcher: %v", err)
	}

	defer watcher.Close()

	// This goroutine continually processes events generated by the fsnotify
	// watcher and hashes files in the background as needed to help speed things
	// up when the hash actually needs to be used.
	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}

				// Don't hash files generated by miniccc, since they rarely need to be
				// transferred between nodes. This shouldn't ever happen since we're not
				// watching any of the miniccc_responses directories, but it doesn't
				// hurt to check here too for completeness sake.
				if strings.Contains(event.Name, "miniccc_responses") {
					continue
				}

				log.Info("NEW FSNOTIFY EVENT: %s", event)

				/*
					if event.Has(fsnotify.Create) {
						stat, err := os.Stat(event.Name)
						if err != nil {
							log.Error("getting stats for newly created file %s: %v", event.Name, err)
							continue
						}

						if stat.IsDir() {
							log.Info("adding new directory %s to watcher", event.Name)
							watcher.Add(event.Name)
						} else {
							log.Info("adding new file %s to list", event.Name)

							info := newFileInfo(event.Name, stat)

							iom.fileLock.Lock()
							iom.files[info.Path] = info
							iom.fileLock.Unlock()
						}
					}

					if event.Has(fsnotify.Write) {
						log.Info("getting hash for file %s", event.Name)

						iom.fileLock.RLock()
						info := iom.files[event.Name]
						iom.fileLock.RUnlock()

						go func() {
							info.Hash, err = hashFile(info.Path)
							if err != nil {
								log.Error("getting hash for file %s: %v", info.Path, err)
								return
							}

							iom.fileLock.Lock()
							iom.files[info.Path] = info
							iom.fileLock.Unlock()
						}()
					}
				*/

				// TODO: figure out what it's going to look like when an image is moved
				// to a node. For example, a bunch of WRITE events in a row? When the
				// mesh is used to transfer files, parts of the file go into a directory
				// that starts with "tmp", so we could ignore them. Then the file is
				// combined, which may still generate a bunch of WRITE events. The
				// fsnotify package has an example of how to dedup all the WRITE events.

				// TODO (future): figure out best way to handle detection of files being
				// moved.  May not happen that often, so not something to worry about
				// right now.
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}

				log.Error("watching for file events: %v", err)
			}
		}
	}()

	/*
		files, err := iom.List("/", true)
		if err != nil {
			log.Fatal("listing files: %v", err)
		}

		// This loop is only run once at startup, and creates a new goroutine for
		// each existing file that needs to be hashed.
		for _, info := range files {
			// Don't hash files generated by miniccc, since they rarely need to be
			// transferred between nodes.
			if strings.Contains(info.Path, "miniccc_responses") {
				continue
			}

			if info.Size == 0 {
				continue
			}

			go func(info FileInfo) {
				var err error

				info.Hash, err = hashFile(info.Path)
				if err != nil {
					log.Error("getting hash for file %s: %v", info.Path, err)
					return
				}

				iom.fileLock.Lock()
				iom.files[info.Path] = info
				iom.fileLock.Unlock()
			}(info)
		}
	*/

	// Don't start watching for fsnotify events until after we've already started
	// hashing all the existing files. There's a very small, very unlikely chance
	// that a new file could be created between the time when we walked all the
	// existing files and we start watching for new files.
	watcher.Add(iom.base)

	err = filepath.Walk(iom.base, func(path string, info os.FileInfo, err error) error {
		// Don't hash files generated by miniccc, since they rarely need to be
		// transferred between nodes.
		if strings.Contains(path, "miniccc_responses") {
			return nil
		}

		if err != nil {
			return err
		}

		if info.IsDir() {
			watcher.Add(path)
		}

		return nil
	})

	if err != nil {
		log.Fatal("walking %s", iom.base)
	}

	// Prevent this function from ever returning so the fsnotify event processing
	// goroutine will stay in scope.
	<-make(chan struct{})
}

// hashFile generates a Murmur hash for the file at the given path.
func hashFile(path string) (string, error) {
	file, err := os.Open(path)
	if err != nil {
		return "", fmt.Errorf("opening file %s for hashing: %w", path, err)
	}

	defer file.Close()
	start := time.Now()

	hasher := murmur3.New64()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", fmt.Errorf("hashing file: %w", err)
	}

	hash := fmt.Sprintf("%x", hasher.Sum(nil))

	log.Info("hashing %s (%s) took %s", path, hash, time.Since(start))

	return hash, nil
}
