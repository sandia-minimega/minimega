// Copyright (2012) Sandia Corporation.
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.

// meshage is a mesh based message passing protocol that supports
// auto-configuration and simple resiliency.
//
// meshage is used by creating a node with a name, namespace, degree of
// connectivity, and a port. Other meshage nodes on the broadcast domain that
// have the same namespace and port will automatically connect in an arbitrary
// graph. Additionally, the user can direct nodes to connect to other nodes
// directly (without requiring they be on the same broadcast domain). Nodes
// must use the same port to communicate, but not necessarily the same
// namespace. Nodes will auto-configure only with other nodes with the same
// namespace, but direct dialing will ignore the namespace.
//
// Messages are passed either as a set of connected nodes or as a broadcast to
// all nodes. A set message is a message sent to one or more nodes on the mesh.
// A broadcast is a message sent to all nodes on the mesh. Messages are
// automatically routed to their destination via the shortest path along the
// mesh. Messages that fail to complete return an error with no retry along an
// alternate route.
//
// The state of the mesh is maintained automatically by connected nodes via
// mesh state announcements (MSA). MSA messages are periodically flooded to all
// nodes by all nodes to determine the mesh topology and routes. The user can
// set the MSA period, which defaults to 10 seconds. When nodes fail or leave
// the mesh unexpectedly, MSA processing will detect the lost node and
// recalculate the topology.
package meshage

import (
	"encoding/gob"
	"errors"
	"fmt"
	"io"
	"math/rand"
	log "minilog"
	"net"
	"sort"
	"strings"
	"sync"
	"time"
)

const (
	DEFAULT_TIMEOUT     = 10
	RECEIVE_BUFFER      = 1024
	DEFAULT_MSA_TIMEOUT = 10
	SOLICIT_LIMIT       = 16 // If fewer than SOLICIT_LIMIT nodes exist in the mesh, everyone tries to connect on solicitations
	SOLICIT_RATIO       = 8  // If greater than SOLICIT_LIMIT nodes exist in the mesh, 1/SOLICIT_RATIO nodes try to connect
)

type mesh map[string][]string

// A Node object contains the network information for a given node. Creating a
// Node object with a non-zero degree will cause it to begin broadcasting for
// connections automatically.
type Node struct {
	name             string             // node name, must be unique on a network
	namespace        string             // namespace, other meshage nodes will connect to solicitations only with this namespace
	degree           uint               // degree for this node, set to 0 to force node not to broadcast
	network          mesh               // adjacency list for the known topology for this node
	effectiveNetwork mesh               // effective topology for pairwise connections from the network
	routes           map[string]string  // one-hop routes for every node on the network, including this node
	receive          chan *Message      // channel of incoming messages, A program will read this channel for incoming messages to this node
	clients          map[string]*client // list of clients to this node
	broadcastIP      net.IP             // IP to broadcast on (UDP only)
	port             int                // port to operate on, uses both tcp and udp
	timeout          time.Duration      // timeout for various non-response elements (Dial, ACK, etc.)
	msaTimeout       time.Duration      // timeout for MSA messages
	errors           chan error         // channel of asynchronous errors generated by meshage
	rand             *rand.Rand         // rand is seeded based on the time when the node is created
	instance         uint64             // random ID for the instance, used for sequences
	messagePump      chan *Message
	sequences        map[uint64]uint64
	clientLock       sync.Mutex
	sequenceLock     sync.Mutex
	degreeLock       sync.Mutex
	meshLock         sync.Mutex
	msaLock          sync.Mutex
	lastMSA          time.Time
	updateNetwork    bool
	Snoop            func(m *Message)
	version          string
}

func init() {
	gob.Register(mesh{})
}

// NewNode returns a new node, receiver channel, and error channel with a given name
// and degree. If degree is non-zero, the node will automatically begin broadcasting
// for connections.
func NewNode(name string, namespace string, degree uint, broadcastIP net.IP, port int, version string) (*Node, chan *Message) {
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	log.Debug("NewNode: %v %v %v %v", name, degree, broadcastIP, port)
	n := &Node{
		name:             name,
		namespace:        namespace,
		degree:           degree,
		network:          make(mesh),
		effectiveNetwork: make(mesh),
		routes:           make(map[string]string),
		receive:          make(chan *Message, RECEIVE_BUFFER),
		clients:          make(map[string]*client),
		broadcastIP:      broadcastIP,
		port:             port,
		timeout:          time.Duration(DEFAULT_TIMEOUT * time.Second),
		msaTimeout:       time.Duration(DEFAULT_MSA_TIMEOUT * time.Second),
		errors:           make(chan error),
		messagePump:      make(chan *Message, RECEIVE_BUFFER),
		sequences:        make(map[uint64]uint64),
		version:          version,
		instance:         r.Uint64(),
		rand:             r,
	}

	go n.connectionListener()
	go n.broadcastListener()
	go n.messageHandler()
	go n.checkDegree()
	go n.periodicMSA()
	go n.periodicEffectiveNetwork()

	return n, n.receive
}

// return the name of this node
func (n *Node) Name() string {
	return n.name
}

// Dial connects a node to another, regardless of degree. Error is nil on success.
func (n *Node) Dial(addr string) error {
	return n.dial(addr, false)
}

// SetDegree sets the degree for the current node. If the degree increases beyond
// the current number of connected clients, it will begin broadcasting for connections.
func (n *Node) SetDegree(degree uint) {
	n.degree = degree
	go n.checkDegree()
}

// GetDegree returns the current degree for the node.
func (n *Node) GetDegree() uint {
	return n.degree
}

// numClients returns the number of clients for the node.
func (n *Node) numClients() uint {
	n.clientLock.Lock()
	defer n.clientLock.Unlock()

	return uint(len(n.clients))
}

// getClient returns the number client or an error if not connected.
func (n *Node) getClient(c string) (*client, error) {
	n.clientLock.Lock()
	defer n.clientLock.Unlock()

	if c, ok := n.clients[c]; ok {
		return c, nil
	}

	return nil, fmt.Errorf("no such client %v", c)
}

// hasClient returns whether we are connected to a client already or not.
func (n *Node) hasClient(client string) bool {
	n.clientLock.Lock()
	defer n.clientLock.Unlock()

	_, ok := n.clients[client]
	return ok
}

// Mesh returns the current known topology as an adjacency list.
func (n *Node) Mesh() mesh {
	n.meshLock.Lock()
	defer n.meshLock.Unlock()

	ret := make(mesh)

	// add self to mesh (in case there is no actual mesh)
	ret[n.name] = nil

	for k, v := range n.effectiveNetwork {
		ns := make([]string, len(v))
		copy(ns, v)
		ret[k] = ns
	}

	return ret
}

// connectionListener accepts connections on tcp/port for both solicited and unsolicited
// client connections.
func (n *Node) connectionListener() {
	log.Debugln("connectionListener")
	ln, err := net.Listen("tcp", fmt.Sprintf(":%d", n.port))
	if err != nil {
		log.Fatalln(err)
	}
	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Warnln(err)
			continue
		}
		n.newConnection(conn)
	}
}

// newConnection processes a new incoming connection from another node, processes the connection
// handshake, adds the connection to the client list, and starts the client message handler.
func (n *Node) newConnection(conn net.Conn) {
	log.Debug("newConnection: %v", conn.RemoteAddr().String())

	// are we soliciting connections?
	var solicited bool
	if n.numClients() < n.degree {
		solicited = true
	} else {
		solicited = false
	}
	log.Debug("solicited: %v", solicited)

	c := &client{
		conn: conn,
		enc:  gob.NewEncoder(conn),
		dec:  gob.NewDecoder(conn),
		ack:  make(chan uint64, RECEIVE_BUFFER),
	}

	// the handshake involves the following:
	// 1.  We send our name, our solicitation status, and our version
	// 2a. If the connection is solicited but we're all full, the remote node simply hangs up
	// 2b. If the connection is unsolicited or solicited and we are still soliciting connections, the remote node responds with its name
	// 3.  The connection is valid, add it to our client list and broadcast a MSA announcing the new connection.
	// 4.  The remote node does the same as 3.
	err := c.enc.Encode(n.name)
	if err != nil {
		log.Error("newConnection encode name: %v: %v", n.name, err)
		c.conn.Close()
		return
	}

	err = c.enc.Encode(solicited)
	if err != nil {
		log.Error("newConnection encode solicited: %v: %v", n.name, err)
		c.conn.Close()
		return
	}

	err = c.enc.Encode(n.version)
	if err != nil {
		log.Error("newConnection encode version: %v: %v", n.name, err)
		c.conn.Close()
		return
	}

	var remoteHost string
	err = c.dec.Decode(&remoteHost)
	if err != nil {
		if err != io.EOF {
			log.Error("newConnection decode name: %v: %v", n.name, err)
		}
		c.conn.Close()
		return
	}

	var remoteVersion string
	err = c.dec.Decode(&remoteVersion)
	if err != nil {
		if err != io.EOF {
			log.Error("newConnection decode version: %v: %v", n.name, err)
		}
		c.conn.Close()
		return
	}
	if remoteVersion != n.version {
		log.Warn("remote node version mismatch on host %v: %v", remoteHost, remoteVersion)
	}

	c.name = remoteHost
	log.Debug("handshake from: %v", c.name)

	n.clientLock.Lock()
	n.clients[remoteHost] = c
	n.clientLock.Unlock()

	go n.clientHandler(remoteHost)
}

// broadcastListener listens for broadcast connection solicitations and connects to
// soliciting nodes.
func (n *Node) broadcastListener() {
	listenAddr := net.UDPAddr{
		IP:   net.IPv4(0, 0, 0, 0),
		Port: n.port,
	}
	ln, err := net.ListenUDP("udp4", &listenAddr)
	if err != nil {
		log.Fatal("broadcastListener: %v", err)
	}
	for {
		d := make([]byte, 1024)
		read, _, err := ln.ReadFromUDP(d)
		if err != nil {
			log.Error("broadcastListener ReadFromUDP: %v", err)
			continue
		}
		data := strings.Split(string(d[:read]), ":")
		if len(data) != 3 {
			log.Warn("got malformed udp data: %v", data)
			continue
		}
		if data[0] != "meshage" {
			log.Warn("got malformed udp data: %v", data)
			continue
		}
		namespace := data[1]
		host := data[2]
		if namespace != n.namespace {
			log.Debug("got solicitation from namespace %v, dropping", namespace)
			continue
		}
		if host == n.name {
			log.Debugln("got solicitation from myself, dropping")
			continue
		}
		log.Debug("got solicitation from %v", host)

		// to avoid spamming the node with connections, only 1/8 of the
		// nodes should try to connect. If there are < 16 nodes, then
		// always try.
		if n.numClients() > SOLICIT_LIMIT {
			n := n.rand.Intn(SOLICIT_RATIO)
			if n != 0 {
				log.Debugln("randomly skipping this solicitation")
				continue
			}
		}
		go n.dial(host, true)
	}
}

// checkDegree broadcasts connection solicitations with exponential backoff until
// the degree is met, then returns. checkDegree locks and will cause the caller to block
// until the degree is met. It should only be run as a goroutine.
func (n *Node) checkDegree() {
	// check degree only if we're not already running
	n.degreeLock.Lock()
	defer n.degreeLock.Unlock()

	var backoff uint = 1
	for n.numClients() < n.degree {
		log.Debugln("soliciting connections")
		addr := net.UDPAddr{
			IP:   n.broadcastIP,
			Port: n.port,
		}
		socket, err := net.DialUDP("udp4", nil, &addr)
		if err != nil {
			log.Error("checkDegree: %v", err)
			break
		}
		message := fmt.Sprintf("meshage:%s:%s", n.namespace, n.name)
		_, err = socket.Write([]byte(message))
		socket.Close()
		if err != nil {
			log.Error("checkDegree: %v", err)
			break
		}
		wait := n.rand.Intn(1 << backoff)
		time.Sleep(time.Duration(wait) * time.Second)
		if backoff < 7 { // maximum wait won't exceed 128 seconds
			backoff++
		}
	}
}

// dial another node, perform a handshake, and add the client to the client list if successful
func (n *Node) dial(host string, solicited bool) error {
	addr := fmt.Sprintf("%s:%d", host, n.port)
	log.Debug("dialing: %v", addr)

	conn, err := net.DialTimeout("tcp", addr, DEFAULT_TIMEOUT*time.Second)
	if err != nil {
		if solicited {
			log.Error("dial %v: %v", host, err)
		}
		return fmt.Errorf("dial %v: %v", host, err)
	}

	c := &client{
		conn: conn,
		enc:  gob.NewEncoder(conn),
		dec:  gob.NewDecoder(conn),
		ack:  make(chan uint64, RECEIVE_BUFFER),
	}

	var remoteHost string
	err = c.dec.Decode(&remoteHost)
	if err != nil {
		if solicited {
			log.Error("dial %v: %v", host, err)
		}
		conn.Close()
		return fmt.Errorf("dial %v: %v", host, err)
	}

	var remoteSolicited bool
	err = c.dec.Decode(&remoteSolicited)
	if err != nil {
		if solicited {
			log.Error("dial %v: %v", host, err)
		}
		conn.Close()
		return fmt.Errorf("dial %v: %v", host, err)
	}

	var remoteVersion string
	err = c.dec.Decode(&remoteVersion)
	if err != nil {
		if solicited {
			log.Error("dial %v: %v", host, err)
		}
		conn.Close()
		return fmt.Errorf("dial %v: %v", host, err)
	}
	if remoteVersion != n.version {
		log.Warn("remote node version mismatch on host %v: %v", host, remoteVersion)
	}

	// are we the remote host?
	if remoteHost == n.name {
		conn.Close()
		return errors.New("cannot mesh dial yourself")
	}

	// are we already connected to this node?
	if n.hasClient(remoteHost) {
		conn.Close()
		return fmt.Errorf("already connected to %v", remoteHost)
	}

	// we should hangup if the connection no longer wants solicited connections and we're solicited
	if solicited && !remoteSolicited {
		conn.Close()
		return nil
	}

	err = c.enc.Encode(n.name)
	if err != nil {
		if solicited {
			log.Error("dial %v: %v", host, err)
		}
		conn.Close()
		return fmt.Errorf("dial %v: %v", host, err)
	}

	err = c.enc.Encode(n.version)
	if err != nil {
		if solicited {
			log.Error("dial %v: %v", host, err)
		}
		conn.Close()
		return fmt.Errorf("dial %v: %v", host, err)
	}

	c.name = remoteHost
	log.Debug("handshake from: %v", remoteHost)

	n.clientLock.Lock()
	n.clients[remoteHost] = c
	n.clientLock.Unlock()

	go n.clientHandler(remoteHost)
	return nil
}

// MSA issues a Meshage State Annoucement, which contains a list of all the nodes connected to the broadcaster
func (n *Node) MSA() {
	log.Debugln("MSA")

	// rate limit MSA spam to once per MSA timeout / 2
	n.msaLock.Lock()
	defer n.msaLock.Unlock()
	if time.Now().Sub(n.lastMSA) < (n.msaTimeout / 2) {
		return
	}
	n.lastMSA = time.Now()

	n.clientLock.Lock()
	var clients []string
	for k, _ := range n.clients {
		clients = append(clients, k)
	}
	n.clientLock.Unlock()

	sort.Strings(clients)

	n.meshLock.Lock()
	diff := false
	if len(n.network[n.name]) != len(clients) {
		diff = true
	} else {
		for i, v := range n.network[n.name] {
			if clients[i] != v {
				diff = true
				break
			}
		}
	}
	if diff {
		log.Debugln("client list changed, recalculating topology")
		n.network[n.name] = clients
		n.updateNetwork = true
	}
	n.meshLock.Unlock()

	if log.WillLog(log.DEBUG) {
		log.Debug("client list: %v", clients)
	}

	if len(clients) == 0 {
		log.Debugln("not issuing MSA, no connected clients")
		return
	}

	m := &Message{
		Source:       n.name,
		Instance:     n.instance,
		CurrentRoute: []string{n.name},
		ID:           n.sequence(),
		Command:      MSA,
		Body:         clients,
	}
	n.flood(m)
}

func (n *Node) sequence() uint64 {
	log.Debugln("sequence")
	n.sequenceLock.Lock()
	defer n.sequenceLock.Unlock()
	n.sequences[n.instance]++
	return n.sequences[n.instance]
}

func (n *Node) handleMSA(m *Message) {
	log.Debug("handleMSA: %v", m)

	n.meshLock.Lock()
	defer n.meshLock.Unlock()

	if len(n.network[m.Source]) == len(m.Body.([]string)) {
		diff := false
		for i, v := range n.network[m.Source] {
			if m.Body.([]string)[i] != v {
				diff = true
				break
			}
		}
		if !diff {
			log.Debugln("MSA discarded, client data hasn't changed")
			return
		}
	}

	n.network[m.Source] = m.Body.([]string)

	if log.WillLog(log.DEBUG) {
		log.Debug("new network is: %v", n.network)
	}

	n.updateNetwork = true
}

func (n *Node) periodicEffectiveNetwork() {
	for {
		time.Sleep(n.GetMSATimeout())
		n.checkUpdateNetwork()
	}
}

func (n *Node) checkUpdateNetwork() {
	n.meshLock.Lock()
	if n.updateNetwork {
		n.generateEffectiveNetwork()
		n.updateNetwork = false
	}
	n.meshLock.Unlock()
}

func (n *Node) periodicMSA() {
	for {
		time.Sleep(n.GetMSATimeout())
		n.MSA()
	}
}

// Set the MSA period, in seconds.
func (n *Node) SetMSATimeout(timeout uint) {
	n.msaLock.Lock()
	defer n.msaLock.Unlock()

	n.msaTimeout = time.Duration(timeout) * time.Second
}

// Return the MSA period, in seconds.
func (n *Node) GetMSATimeout() time.Duration {
	n.msaLock.Lock()
	defer n.msaLock.Unlock()

	return n.msaTimeout
}
