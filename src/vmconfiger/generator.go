// Copyright (2016) Sandia Corporation.
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	log "minilog"
	"os"
	"sort"
	"strings"
	"text/template"
)

const Default = "Default: "

type Field struct {
	Field, ConfigName, Type, Default string
}

type Fields []Field

func (f Fields) Len() int           { return len(f) }
func (f Fields) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }
func (f Fields) Less(i, j int) bool { return f[i].Field < f[j].Field }

type Generator struct {
	types []string
	pkg   *build.Package
	buf   bytes.Buffer

	template *template.Template

	// mapping from type to list of fields
	fields map[string][]Field
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) Execute(name string, data interface{}) {
	if err := g.template.ExecuteTemplate(&g.buf, name, data); err != nil {
		log.Error("executing %v: %v", name, err)
	}
}

// Format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) Format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Error("invalid Go generated: %s", err)
		log.Error("compile the package to analyze the error")
		return g.buf.Bytes()
	}

	return src
}

func (g *Generator) Run() error {
	fs := token.NewFileSet()

	t := template.Must(template.New("string").Parse(stringTemplate))
	template.Must(t.New("uint64").Parse(uint64Template))
	template.Must(t.New("bool").Parse(boolTemplate))
	template.Must(t.New("slice").Parse(sliceTemplate))
	template.Must(t.New("clear").Parse(clearTemplate))
	template.Must(t.New("funcs").Parse(funcsTemplate))

	g.template = t

	pkgs, err := parser.ParseDir(fs, g.pkg.Dir, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	if _, ok := pkgs[g.pkg.Name]; !ok {
		return fmt.Errorf("parsing package did not include %v", g.pkg.Name)
	}

	if err := checkTypes(g.pkg.Dir, fs, pkgs[g.pkg.Name]); err != nil {
		return err
	}

	// Print the header and package clause.
	g.Printf("// Code generated by \"vmconfiger %s\"; DO NOT EDIT\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s", g.pkg.Name)
	g.Printf("\n")
	g.Printf("import (\n")
	g.Printf("\t\"fmt\"\n")
	g.Printf("\t\"minicli\"\n")
	g.Printf("\tlog \"minilog\"\n")
	g.Printf("\t\"os\"\n")
	g.Printf("\t\"path/filepath\"\n")
	g.Printf("\t\"strconv\"\n")
	g.Printf(")\n")
	g.Printf("var vmconfigerCLIHandlers = []minicli.Handler{\n")

	g.fields = map[string][]Field{}

	// go through files in sorted order to make the output more deterministic
	var files []string
	for f := range pkgs[g.pkg.Name].Files {
		files = append(files, f)
	}
	sort.Strings(files)

	for _, file := range files {
		log.Debug("inspecting %v", file)
		ast.Inspect(pkgs[g.pkg.Name].Files[file], g.handleNode)
	}

	if len(g.fields) > 0 {
		var fields Fields
		for _, f := range g.fields {
			fields = append(fields, f...)
		}
		sort.Sort(fields)
		g.Execute("clear", fields)
	}

	g.Printf("}\n")

	if len(g.fields) > 0 {
		g.Execute("funcs", g.fields)
	}

	return nil
}

func (g *Generator) handleNode(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.TYPE {
		return true
	}

	for _, spec := range decl.Specs {
		tspec := spec.(*ast.TypeSpec)

		var match bool
		for _, v := range g.types {
			if v == tspec.Name.Name {
				match = true
			}
		}
		if !match {
			log.Debug("skipping %v", tspec.Name)
			return true
		}

		strct, ok := tspec.Type.(*ast.StructType)
		if !ok {
			log.Fatal("%v is not a struct", tspec.Name)
		}

		log.Info("found %v", tspec.Name)
		strctName := tspec.Name.String()

		for _, field := range strct.Fields.List {
			log.Info("%#v", field)
			name := field.Names[0].Name
			doc := field.Doc.Text()

			configName := name
			if strings.Contains(name, "Path") {
				// trim both path and paths, should only contain one
				configName = strings.TrimSuffix(configName, "Path")
				configName = strings.TrimSuffix(configName, "Paths")
			}
			configName = camelToHyphenated(configName)

			switch typ := field.Type.(type) {
			case *ast.Ident:
				var zero string
				var unhandled bool

				switch typ.Name {
				case "string":
					zero = getDefault(doc, `""`)
				case "uint64":
					zero = getDefault(doc, `0`)
				case "bool":
					zero = getDefault(doc, `false`)
				default:
					log.Error("unhandled type: %v", typ)
					unhandled = true
					zero = "nil"
				}

				g.fields[strctName] = append(g.fields[strctName], Field{
					name, configName, typ.Name, zero,
				})

				if unhandled {
					continue
				}

				g.Execute(typ.Name, struct {
					Field, ConfigName, Doc string
					Path                   bool
				}{
					name, configName, doc,
					strings.Contains(name, "Path"),
				})
			case *ast.ArrayType:
				v, ok := typ.Elt.(*ast.Ident)
				if !ok || v.Name != "string" {
					// always add field, even if we don't generate the handler
					g.fields[strctName] = append(g.fields[strctName], Field{
						name, configName, "", "nil",
					})

					continue
				}

				zero := getDefault(doc, "")
				if f := strings.Fields(zero); len(f) > 0 {
					for i := range f {
						f[i] = strings.TrimSuffix(f[i], ",")
					}
					zero = fmt.Sprintf("[]string{%v}", strings.Join(f, ","))
				} else {
					zero = "nil"
				}

				g.fields[strctName] = append(g.fields[strctName], Field{
					name, configName, "", zero,
				})

				g.Execute("slice", struct {
					Field, ConfigName, Doc string
					Path                   bool
				}{
					name, configName, doc,
					strings.Contains(name, "Path"),
				})
			default:
				log.Error("unhandled type for %v: %v", name, typ)
				// always add field, even if we don't generate the handler
				g.fields[strctName] = append(g.fields[strctName], Field{
					name, configName, "", "nil",
				})
			}
		}
	}

	return false
}

// getDefault parses out the "Default: X" in s. If no default is found, d is
// returned instead.
func getDefault(s, d string) string {
	if strings.Contains(s, Default) {
		return strings.TrimSpace(s[strings.Index(s, Default)+len(Default):])
	}

	return d
}
